@using Aurigma.Design
@using Aurigma.Design.Math
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@inject IJSRuntime JsRuntime

<div style="background-color: gray; position: absolute; width: @(Width)px; height: @(Height)px">
    <BECanvas Width="@Width" Height="@Height" @ref="_canvasReference"></BECanvas>
</div>
<div style="position: absolute; width: @(Width)px; height: @(Height)px" 
    @onmousedown="OnMouseDown" 
    @onmouseup="OnMouseUp" 
    @onmousemove="OnMouseMove"
    @onmouseout="OnMouseOut">
    <BECanvas Width="@Width" Height="@Height" @ref="_uiCanvasReference"></BECanvas>
</div>

@code {
    private Design _design;
    private int _currentSurfaceIndex;
    private BECanvasComponent _canvasReference;
    private BECanvasComponent _uiCanvasReference;
    private Canvas2DContext _outputCanvasContext;
    private Canvas2DContext _uiCanvasContext;
    private IJSObjectReference _module;
    private DotNetObjectReference<DesignViewer> _instanceRef;

    // Use ScrollX property instead
    private float _scrollX = 0f;

    // Use ScrollY property instead
    private float _scrollY = 0f;
    private float _zoom = 5f;

    private float _scrollbarSize = 16f;

    private bool _isHorizontalScrollbarHeld;
    private bool _isVerticalScrollbarHeld;
    private bool _isMouseOut;
    private double _prevMouseX;
    private double _prevMouseY;

    [Parameter]
    public long Width { get; set; } = 256;

    [Parameter]
    public long Height { get; set; } = 256;

    [Parameter]
    public Sides ArtboardScrollMargin { get; set; } = new Sides(0f);

    public bool IsHorizontalScrollbarShown
    {
        get
        {
            return CurrentArtboard.Size.Width * _zoom 
                + ArtboardScrollMargin.Left
                + ArtboardScrollMargin.Right > Width;
        }
    }

    public bool IsVerticalScrollbarShown
    {
        get
        {
            return CurrentArtboard.Size.Height * _zoom
                + ArtboardScrollMargin.Top
                + ArtboardScrollMargin.Bottom > Height;
        }
    }

    [JSInvokable]
    public async ValueTask ViewerRenderLoop(float timeStamp)
    {
        await RedrawCanvasAsync(timeStamp);
        await RedrawUiCanvasAsync(timeStamp);

        RequestRendering();
    }

    public void SetDesign(Design design)
    {
        _design = design;
        RequestRendering();
    }

    public void SetCurrentSurfaceIndex(int index)
    {
        _currentSurfaceIndex = index;       
        RequestRendering();
    }

    private Surface CurrentSurface
    {
        get
        {
            return _design.Surfaces[_currentSurfaceIndex];
        }
    }

    private Artboard CurrentArtboard
    {
        get
        {
            return CurrentSurface.Artboards.First();
        }
    }

    private float MinScrollX
    {
        get
        {
            return (Width - (CurrentArtboard.Size.Width * _zoom)) / 2f
                        - ArtboardScrollMargin.Right;
        }
    }

    private float MaxScrollX
    {
        get
        {
            return ArtboardScrollMargin.Left
                        - (Width - (CurrentArtboard.Size.Width * _zoom)) / 2f;
        }
    }

    private float MinScrollY
    {
        get
        {
            return (Height - (CurrentArtboard.Size.Height * _zoom)) / 2f
                        - ArtboardScrollMargin.Bottom;
        }
    }

    private float MaxScrollY
    {
        get
        {
            return ArtboardScrollMargin.Top
                        - (Height - (CurrentArtboard.Size.Height * _zoom)) / 2f;
        }
    }

    private float ScrollX
    {
        get
        {
            return _scrollX;
        }
        set
        {
            if(value < MinScrollX)
            {
                _scrollX = MinScrollX;
                return;
            }
            if(value > MaxScrollX)
            {
                _scrollX = MaxScrollX;
                return;
            }

            _scrollX = value;
        }
    }

    private float ScrollY
    {
        get
        {
            return _scrollY;
        }
        set
        {
            if(value < MinScrollY)
            {
                _scrollY = MinScrollY;
                return;
            }
            if(value > MaxScrollY)
            {
                _scrollY = MaxScrollY;
                return;
            }

            _scrollY = value;
        }
    }

    private float ScrollableAreaHeight
    {
        get
        {
            return CurrentArtboard.Size.Height * _zoom
                + ArtboardScrollMargin.Top
                + ArtboardScrollMargin.Bottom;
        }
    }

    private float ScrollableAreaWidth
    {
        get
        {
            return CurrentArtboard.Size.Width * _zoom
                + ArtboardScrollMargin.Left
                + ArtboardScrollMargin.Right;
        }
    }

    private float VerticalScrollbarPos
    {
        get
        {
            float topLimitY = (Height - CurrentArtboard.Size.Height * _zoom) / 2f 
                + ScrollY - ArtboardScrollMargin.Top;

            return -topLimitY * (Height - _scrollbarSize) / ScrollableAreaHeight;
        }
    }

    private float HorizontalScrollbarPos
    {
        get
        {
            float leftLimitX = (Width - CurrentArtboard.Size.Width * _zoom) / 2f 
                + ScrollX - ArtboardScrollMargin.Left;

            return -leftLimitX * (Width - _scrollbarSize) / ScrollableAreaWidth;
        }
    }

    private float VerticalScrollbarHeight
    {
        get
        {
            return Height * (Height - _scrollbarSize) / ScrollableAreaHeight;
        }
    }

    private float HorizontalScrollbarWidth
    {
        get
        {
            return Width * (Width - _scrollbarSize) / ScrollableAreaWidth;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _outputCanvasContext = await _canvasReference.CreateCanvas2DAsync();
            _uiCanvasContext = await _uiCanvasReference.CreateCanvas2DAsync();

            _module = await JsRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/BlazorExtensions/DesignViewer.razor.js");

            _instanceRef = DotNetObjectReference.Create(this);

            RequestRendering();
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    private void RequestRendering()
    {
        if (_module == null || _instanceRef == null)
        {
            return;
        }

        _module.InvokeVoidAsync("callRequestAnimationFrame", _instanceRef);
    }

    private void OnMouseDown(MouseEventArgs e)
    {
        if(e.Button == 0)
        {
            if(IsHorizontalScrollbarShown 
                && e.OffsetX >= HorizontalScrollbarPos
                && e.OffsetX <= HorizontalScrollbarPos + HorizontalScrollbarWidth
                && e.OffsetY > Height - _scrollbarSize
                && e.OffsetY < Height)
            {
                _isHorizontalScrollbarHeld = true;
                _prevMouseX = e.OffsetX;
            }
            else if(IsVerticalScrollbarShown
                && e.OffsetX >= Width - _scrollbarSize
                && e.OffsetX <= Width
                && e.OffsetY > VerticalScrollbarPos
                && e.OffsetY < VerticalScrollbarPos + VerticalScrollbarHeight)
            {
                _isVerticalScrollbarHeld = true;
                _prevMouseY = e.OffsetY;
            }
        }
    }

    private void OnMouseMove(MouseEventArgs e)
    {
        if(_isHorizontalScrollbarHeld)
        {
            float dx = (float)(e.OffsetX - _prevMouseX);
            ScrollX += GetScrollXFromScrollbarShift(dx);
        }
        else if(_isVerticalScrollbarHeld)
        {
            float dy = (float)(e.OffsetY - _prevMouseY);
            ScrollY += GetScrollYFromScrollbarShift(dy);
        }

        _prevMouseX = e.OffsetX;
        _prevMouseY = e.OffsetY;
    }

    private void OnMouseUp(MouseEventArgs e)
    {
        if(e.Button == 0)
        {
            _isHorizontalScrollbarHeld = false;
            _isVerticalScrollbarHeld = false;
        }
    }

    private void OnMouseOut()
    {
        _isHorizontalScrollbarHeld = false;
        _isVerticalScrollbarHeld = false;
    }

    private float GetScrollXFromScrollbarShift(float shift)
    {
        return ScrollableAreaWidth * -shift / (Width - _scrollbarSize);
    }

    private float GetScrollYFromScrollbarShift(float shift)
    {
        return ScrollableAreaHeight * -shift / (Height - _scrollbarSize);
    }

    private async Task RedrawCanvasAsync(float timeStamp)
    {
        Size size = CurrentArtboard.Size;
        Affine2DMatrix transform = CurrentSurface.Artboards.First().Basis;
        Point shiftToCenter = new Point(
            (Width - size.Width * _zoom) / 2, 
            (Height - size.Height * _zoom) / 2);
        Point scroll = new Point(ScrollX, ScrollY);

        transform = transform
            .Translate(shiftToCenter)
            .Translate(scroll)
            .Scale(_zoom);

        await _outputCanvasContext.SetTransformAsync(1, 0, 0, 1, 0, 0);
        await _outputCanvasContext.ClearRectAsync(0, 0, Width, Height);

        await _outputCanvasContext.SetTransformAsync(
        transform.M11,
        transform.M12,
        transform.M21,
        transform.M22,
        transform.D1,
        transform.D2);      

        await _outputCanvasContext.SetFillStyleAsync("lightgray");
        await _outputCanvasContext.FillRectAsync(0, 0, size.Width, size.Height);

        await _outputCanvasContext.SetFillStyleAsync("black");
        await _outputCanvasContext.SetFontAsync("20px verdana");
        await _outputCanvasContext.FillTextAsync($"scrollX: {ScrollX.ToString("N2")}", 10, 30);
        await _outputCanvasContext.FillTextAsync($"scrollY: {ScrollY.ToString("N2")}", 10, 50);
        await _outputCanvasContext.FillTextAsync($"zoom: {_zoom.ToString("N2")}", 10, 70);
    }

    private async Task RedrawUiCanvasAsync(float timeStamp)
    {
        await _uiCanvasContext.SetGlobalAlphaAsync(0.66f);
        await _uiCanvasContext.ClearRectAsync(0, 0, Width, Height);

        await _uiCanvasContext.SetStrokeStyleAsync("red");
        await _uiCanvasContext.StrokeRectAsync(0, 0, Width, Height);

        await _uiCanvasContext.SetFillStyleAsync("red");
        await _uiCanvasContext.SetFontAsync("20px verdana");
        await _uiCanvasContext.FillTextAsync($"{_isHorizontalScrollbarHeld}", 20, 50);
        await _uiCanvasContext.FillTextAsync($"{_isVerticalScrollbarHeld}", 20, 70);

        if(IsHorizontalScrollbarShown)
        {
            await RedrawHorizontalScrollbarAsync();
        }
        if(IsVerticalScrollbarShown)
        {
            await RedrawVerticalScrollbarAsync();
        }    
    }

    private async Task RedrawVerticalScrollbarAsync()
    {
        float verticalScrollbarX = Width - _scrollbarSize;

        await _uiCanvasContext.SetFillStyleAsync("#F4D3FF");
        await _uiCanvasContext.FillRectAsync(
            verticalScrollbarX, 
            0, 
            _scrollbarSize, 
            Height - _scrollbarSize);

        await _uiCanvasContext.SetFillStyleAsync("#C182D6");
        await _uiCanvasContext.FillRectAsync(
            verticalScrollbarX,
            VerticalScrollbarPos,
            _scrollbarSize,
            VerticalScrollbarHeight);
    }

    private async Task RedrawHorizontalScrollbarAsync()
    {
        float horizontalScrollbarY = Height - _scrollbarSize;

        await _uiCanvasContext.SetFillStyleAsync("#F4D3FF");
        await _uiCanvasContext.FillRectAsync(
            0, 
            horizontalScrollbarY, 
            Width - _scrollbarSize, 
            _scrollbarSize);

        await _uiCanvasContext.SetFillStyleAsync("#C182D6");
        await _uiCanvasContext.FillRectAsync(
            HorizontalScrollbarPos,
            horizontalScrollbarY,
            HorizontalScrollbarWidth,
            _scrollbarSize);
    }
}
